var documenterSearchIndex = {"docs":
[{"location":"tutorial/EmpiricalApproaches/#Empirical-Approaches","page":"Empirical Approaches","title":"Empirical Approaches","text":"","category":"section"},{"location":"tutorial/EmpiricalApproaches/","page":"Empirical Approaches","title":"Empirical Approaches","text":"Before jumping into systematic solutions of the dynamics of open quantum systems, let us illustrate a couple of ad-hoc approaches to modeling such systems. The first approach considered here is the celebrated Linblad Master Equations. Thereafter, we also demonstrate how to use QuantumDynamics to simulate the dynamics corresponding to non-Hermitian systems.","category":"page"},{"location":"tutorial/EmpiricalApproaches/","page":"Empirical Approaches","title":"Empirical Approaches","text":"For all the examples that are shown here, the following setup remains the same:","category":"page"},{"location":"tutorial/EmpiricalApproaches/","page":"Empirical Approaches","title":"Empirical Approaches","text":"using QuantumDynamics\nusing Plots, LaTeXStrings\n\ndt = 0.125\nntimes = 200\n\nρ0 = [1.0+0.0im 0.0; 0.0 0.0]","category":"page"},{"location":"tutorial/EmpiricalApproaches/","page":"Empirical Approaches","title":"Empirical Approaches","text":"We are using a time-step of 0125 and simulating for 200 time steps. We start the simulation from an initial condition localized on one of the states.","category":"page"},{"location":"tutorial/EmpiricalApproaches/#Bare-Hermitian-System","page":"Empirical Approaches","title":"Bare Hermitian System","text":"","category":"section"},{"location":"tutorial/EmpiricalApproaches/","page":"Empirical Approaches","title":"Empirical Approaches","text":"The Hermitian Hamiltonian considered here is:","category":"page"},{"location":"tutorial/EmpiricalApproaches/","page":"Empirical Approaches","title":"Empirical Approaches","text":"H = [0.0+0.0im -1.0; -1.0 0.0]","category":"page"},{"location":"tutorial/EmpiricalApproaches/","page":"Empirical Approaches","title":"Empirical Approaches","text":"Now we solve Heisenberg's equation of motion for the reduced density matrix:","category":"page"},{"location":"tutorial/EmpiricalApproaches/","page":"Empirical Approaches","title":"Empirical Approaches","text":"times, ρs = Bare.propagate(; Hamiltonian=H, ρ0, dt, ntimes);\nplot(times, real(ρs[:,1,1]), label=L\"P_1(t)\", lw = 2)\nplot!(times, real(ρs[:,2,2]), label=L\"P_2(t)\", lw = 2)\nxlabel!(L\"t\")\nylabel!(\"Population\")","category":"page"},{"location":"tutorial/EmpiricalApproaches/#Linblad-Master-Equation","page":"Empirical Approaches","title":"Linblad Master Equation","text":"","category":"section"},{"location":"tutorial/EmpiricalApproaches/","page":"Empirical Approaches","title":"Empirical Approaches","text":"The same interface can be used to solve the Linblad Master Equation by providing an array of non-Hermitian dissipative collapse operators, L.","category":"page"},{"location":"tutorial/EmpiricalApproaches/","page":"Empirical Approaches","title":"Empirical Approaches","text":"L = [[0.0+0.0im 0; 0.75 0]]\ntimes, ρs = Bare.propagate(; Hamiltonian=H, ρ0, dt, ntimes, L);\nplot(times, real(ρs[:,1,1]), label=L\"P_1(t)\", lw = 2)\nplot!(times, real(ρs[:,2,2]), label=L\"P_2(t)\", lw = 2)\nxlabel!(L\"t\")\nylabel!(\"Population\")\nylabel!(\"Population\")","category":"page"},{"location":"tutorial/EmpiricalApproaches/#Non-Hermitian-System","page":"Empirical Approaches","title":"Non-Hermitian System","text":"","category":"section"},{"location":"tutorial/EmpiricalApproaches/","page":"Empirical Approaches","title":"Empirical Approaches","text":"Dynamics described by non-Hermitian systems is heavily dependent on the type of non-Hermitian term. Consider an arbitrary non-PT-symmetric non-Hermitian Hamiltonian.","category":"page"},{"location":"tutorial/EmpiricalApproaches/","page":"Empirical Approaches","title":"Empirical Approaches","text":"H = [exp(-1.5im) -0.75; -0.75 exp(0.75im)]\ndatum = (H[1,1]+H[2,2])/2\nH[1,1] -= datum\nH[2,2] -= datum\nH","category":"page"},{"location":"tutorial/EmpiricalApproaches/","page":"Empirical Approaches","title":"Empirical Approaches","text":"The dynamics is simulated in a way that is identical to that of the bare Hermitian system.","category":"page"},{"location":"tutorial/EmpiricalApproaches/","page":"Empirical Approaches","title":"Empirical Approaches","text":"times, ρs = Bare.propagate(; Hamiltonian=H, ρ0, dt, ntimes);\nplot(times, real(ρs[:,1,1]), label=L\"P_1(t)\", lw = 2)\nplot!(times, real(ρs[:,2,2]), label=L\"P_2(t)\", lw = 2)\nxlabel!(L\"t\")\nylabel!(\"Population\")","category":"page"},{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"tutorial/QCPI/#Quantum-Classical-Path-Integral-(QCPI)","page":"Quantum-Classical Path Integral","title":"Quantum-Classical Path Integral (QCPI)","text":"","category":"section"},{"location":"tutorial/QCPI/","page":"Quantum-Classical Path Integral","title":"Quantum-Classical Path Integral","text":"QCPI is a numerically exact method for simulating a quantum system interacting with a large thermal environment. This environment is described through force-fields or ab initio molecular dynamics trajectories. While the Gaussian response results are often very good, it is an exciting prospect to be able to solve the full atomistic problem. Here, we implement the harmonic-backreaction (HBR) version of QCPI, which charts a middle-ground between the solution to the fully atomistic problem and the fully harmonic problem. In HBR, the full anharmonicity of the solvent is taken into account in the classical temperature-dependent part of the memory. The quantum, temperature-independent part of the memory is dealt with harmonically.","category":"page"},{"location":"tutorial/QCPI/","page":"Quantum-Classical Path Integral","title":"Quantum-Classical Path Integral","text":"In QuantumDynamics, QCPI is a wrapper around other base path integral methods like QuAPI, TNPI, or Blips. So, we automatically get standard HBR-QCPI (a combination QCPI with QuAPI), blip HBR-QCPI (a combination of QCPI with blips) and HBR-TNPI (a combination of QCPI with TNPI) based on the \"backend\" used.","category":"page"},{"location":"tutorial/QCPI/#Example","page":"Quantum-Classical Path Integral","title":"Example","text":"","category":"section"},{"location":"tutorial/QCPI/","page":"Quantum-Classical Path Integral","title":"Quantum-Classical Path Integral","text":"The basic simulation starts in a manner that should familiar from the setup of a QuAPI or TNPI simulation.","category":"page"},{"location":"tutorial/QCPI/","page":"Quantum-Classical Path Integral","title":"Quantum-Classical Path Integral","text":"using Revise\nusing QuantumDynamics\nusing Plots, LaTeXStrings\n\nH0 = [1.0+0.0im -1.0; -1.0 -1.0]\nρ0 = [1.0+0.0im 0.0; 0.0 0.0]\nβ = 5.0\ndt = 0.25\nntimes = 100\nnothing","category":"page"},{"location":"tutorial/QCPI/","page":"Quantum-Classical Path Integral","title":"Quantum-Classical Path Integral","text":"Right now QCPI only supports harmonic solvents, but it is possible to code up generic atomistic solvents or simply provide adapters for packages like Molly.jl or DFTK.jl. So, let's define the harmonic bath and discretize it into 100 oscillators for the classical trajectories.","category":"page"},{"location":"tutorial/QCPI/","page":"Quantum-Classical Path Integral","title":"Quantum-Classical Path Integral","text":"Jw = SpectralDensities.ExponentialCutoff(; ξ=0.1, ωc=7.5)    # 1.2 Define the spectral density\nω, c = SpectralDensities.discretize(Jw, 100)\nhb = Solvents.HarmonicBath(β, ω, c, [1.0, -1.0], 4000);\nnothing","category":"page"},{"location":"tutorial/QCPI/","page":"Quantum-Classical Path Integral","title":"Quantum-Classical Path Integral","text":"SpectralDensities.discretize discretizes a given spectral density into oscillators. Then we create a Solvents.HarmonicBath bath at the given inverse temperature, with the frequencies and couplings. The last two arguments to Solvents.HarmonicBath are the system operator along which the solvent acts and the number of initial conditions that would be sampled. How the solvent samples the phase-space is dependent on the particular implementation. For a harmonic bath, one can simply sample the multidimensional Gaussian distributions. For molecular solvents, one can implement molecular dynamics trajectories with a thermostat.","category":"page"},{"location":"tutorial/QCPI/","page":"Quantum-Classical Path Integral","title":"Quantum-Classical Path Integral","text":"One can generate the ensemble averaged classical path result, which contains only the real part of memory. This involves generating the correct propagators and using them to propagate an initial reduced density matrix.","category":"page"},{"location":"tutorial/QCPI/","page":"Quantum-Classical Path Integral","title":"Quantum-Classical Path Integral","text":"EACP_fbU = Propagators.calculate_average_reference_propagators(; Hamiltonian=H0, solvent=hb, classical_dt=dt/100, dt, ntimes);\ntimes_EACP, ρs_EACP = Utilities.apply_propagator(; propagators=EACP_fbU, ρ0, ntimes, dt);","category":"page"},{"location":"tutorial/QCPI/","page":"Quantum-Classical Path Integral","title":"Quantum-Classical Path Integral","text":"For a full QCPI calculation, we use the propagate interface:","category":"page"},{"location":"tutorial/QCPI/","page":"Quantum-Classical Path Integral","title":"Quantum-Classical Path Integral","text":"times_QCPI, ρs_QCPI = QCPI.propagate(; Hamiltonian=H0, Jw, solvent=hb, ρ0, classical_dt=dt/100, dt, ntimes, kmax=3, extraargs=QuAPI.QuAPIArgs(), path_integral_routine=QuAPI.propagate)","category":"page"},{"location":"tutorial/QCPI/","page":"Quantum-Classical Path Integral","title":"Quantum-Classical Path Integral","text":"Lastly, we run a TTM-QuAPI simulation for comparison and plot the results.","category":"page"},{"location":"tutorial/QCPI/","page":"Quantum-Classical Path Integral","title":"Quantum-Classical Path Integral","text":"fbU = Propagators.calculate_bare_propagators(; Hamiltonian=H0, dt, ntimes);\n@time times, ρs = TTM.propagate(; fbU=fbU, Jw=[Jw], β, ρ0, dt, ntimes, rmax=9, extraargs=Blip.BlipArgs(), path_integral_routine=Blip.build_augmented_propagator)\nplot(times, real.(ρs[:,1,1] .- ρs[:,2,2]), ylim=(-1,1), xlim=(0,25), label=\"QuAPI\")\nplot!(times_EACP, real.(ρs_EACP[:,1,1] .- ρs_EACP[:,2,2]), label=\"EACP\")\nplot!(times_QCPI, real.(ρs_QCPI[:,1,1] .- ρs_QCPI[:,2,2]), label=\"QCPI\")\nxlabel!(L\"t\")\nylabel!(L\"\\langle\\sigma_z(t)\\rangle\")","category":"page"},{"location":"documentation/BlochRedfield/#Bloch-Redfield-Master-Equation","page":"Bloch-Redfield Master Equation","title":"Bloch-Redfield Master Equation","text":"","category":"section"},{"location":"documentation/BlochRedfield/#API","page":"Bloch-Redfield Master Equation","title":"API","text":"","category":"section"},{"location":"documentation/BlochRedfield/","page":"Bloch-Redfield Master Equation","title":"Bloch-Redfield Master Equation","text":"BlochRedfield.propagate","category":"page"},{"location":"documentation/BlochRedfield/#QuantumDynamics.BlochRedfield.propagate","page":"Bloch-Redfield Master Equation","title":"QuantumDynamics.BlochRedfield.propagate","text":"propagate(; Hamiltonian::Matrix{ComplexF64}, Jw::Vector{T}, β::Real, ρ0::Matrix{ComplexF64}, dt::Real, ntimes::Int, svec::Vector{Matrix{Float64}}, extraargs::Utilities.DiffEqArgs) where {T<:SpectralDensities.AnalyticalSpectralDensity}\n\nGiven a system Hamiltonian, the spectral densities describing the solvent, Jw, and an inverse temperature, this uses Bloch-Redfield Master Equations to propagate the input initial reduced density matrix, ρ0, with a time-step of dt for ntimes time steps. The ith bath, described by Jw[i], interacts with the system through the operator with the values of svec[j]. The default solver used here is Tsit5 with a relative and absolute error cutoffs of 1e-10.\n\n\n\n\n\n","category":"function"},{"location":"documentation/BlochRedfield/","page":"Bloch-Redfield Master Equation","title":"Bloch-Redfield Master Equation","text":"BlochRedfield.get_Rtensor","category":"page"},{"location":"documentation/BlochRedfield/#QuantumDynamics.BlochRedfield.get_Rtensor","page":"Bloch-Redfield Master Equation","title":"QuantumDynamics.BlochRedfield.get_Rtensor","text":"get_Rtensor(eigvals, eigvecs, Jw::Vector{T}, svec::Vector{Matrix{Float64}}, β::Real) where {T<:SpectralDensities.AnalyticalSpectralDensity}\n\nCalculates the Bloch-Redfield R tensor given the eigenvalues, eigvals, and eigenvectors, eigvecs, of the system Hamiltonian, an inverse temperature \beta, and a number of baths specified by their spectral densities, Jw, and the operator through which they interact, svec.\n\n\n\n\n\n","category":"function"},{"location":"documentation/HEOM/#Hierarchy-Equations-of-Motion","page":"Hierarchy Equations of Motion","title":"Hierarchy Equations of Motion","text":"","category":"section"},{"location":"documentation/HEOM/","page":"Hierarchy Equations of Motion","title":"Hierarchy Equations of Motion","text":"This module provides the necessary tools for doing HEOM simulations. While the equations of motion have been reported in many articles, the current implementation is based on a relatively recent paper, HEOM1. It should be noted that this is a particularly naive implementation of the algorithm that only works for the simplest of case of a Drude-Lorentz spectral density.","category":"page"},{"location":"documentation/HEOM/#API","page":"Hierarchy Equations of Motion","title":"API","text":"","category":"section"},{"location":"documentation/HEOM/","page":"Hierarchy Equations of Motion","title":"Hierarchy Equations of Motion","text":"HEOM.propagate","category":"page"},{"location":"documentation/HEOM/#QuantumDynamics.HEOM.propagate","page":"Hierarchy Equations of Motion","title":"QuantumDynamics.HEOM.propagate","text":"propagate(; Hamiltonian::Matrix{ComplexF64}, ρ0::Matrix{ComplexF64}, β::Real, Jw::Vector{SpectralDensities.DrudeLorentzCutoff}, sys_ops::Vector{Matrix{ComplexF64}}, num_modes::Int, Lmax::Int, dt::Real, ntimes::Int, extraargs::Utilities.DiffEqArgs=Utilities.DiffEqArgs())\n\nUses HEOM to propagate the initial reduced density matrix, ρ0, under the given Hamiltonian, and set of spectral densities, Jw, interacting with the system through sys_ops.\n\n`ρ0`: initial reduced density matrix\n`Hamiltonian`: system Hamiltonian\n`Jw`: array of spectral densities\n`sys_ops`: system operators through which the corresponding baths interact\n\n`num_modes`: number of Matsubara modes to be considered\n`Lmax`: cutoff for maximum number of levels\n`dt`: time-step for recording the density matrices\n`ntimes`: number of time steps of simulation\n`extraargs`: extra arguments for the differential equation solver\n\n\n\n\n\n","category":"function"},{"location":"documentation/SpectralDensities/#Spectral-Densities","page":"Spectral Densities","title":"Spectral Densities","text":"","category":"section"},{"location":"documentation/SpectralDensities/","page":"Spectral Densities","title":"Spectral Densities","text":"The interaction of a quantum system with a condensed phase environment is often captured through the spectral density. QuantumDynamics has a built-in support for a few of the most common spectral densities and allows for easy incorporation of other spectral densities.","category":"page"},{"location":"documentation/SpectralDensities/#API","page":"Spectral Densities","title":"API","text":"","category":"section"},{"location":"documentation/SpectralDensities/","page":"Spectral Densities","title":"Spectral Densities","text":"SpectralDensities","category":"page"},{"location":"documentation/SpectralDensities/#QuantumDynamics.SpectralDensities","page":"Spectral Densities","title":"QuantumDynamics.SpectralDensities","text":"Collection of spectral densities commonly used to describe solvents.\n\n\n\n\n\n","category":"module"},{"location":"documentation/SpectralDensities/","page":"Spectral Densities","title":"Spectral Densities","text":"SpectralDensities.ExponentialCutoff","category":"page"},{"location":"documentation/SpectralDensities/#QuantumDynamics.SpectralDensities.ExponentialCutoff","page":"Spectral Densities","title":"QuantumDynamics.SpectralDensities.ExponentialCutoff","text":"ExponentialCutoff(; ξ, ωc, n=1.0, Δs=2.0)\n\nConstruct a model spectral density with an exponential cutoff.\n\nJ(ω) = frac2πΔs^2 ξ fracω^nω_c^n-1 expleft(-fracωωcright)\n\nwhere Δs is the distance between the two system states. The model is Ohmic if n = 1, sub-Ohmic if n < 1, and super-Ohmic if n > 1.\n\n\n\n\n\n","category":"type"},{"location":"documentation/SpectralDensities/","page":"Spectral Densities","title":"Spectral Densities","text":"SpectralDensities.DrudeLorentzCutoff","category":"page"},{"location":"documentation/SpectralDensities/#QuantumDynamics.SpectralDensities.DrudeLorentzCutoff","page":"Spectral Densities","title":"QuantumDynamics.SpectralDensities.DrudeLorentzCutoff","text":"DrudeLorentzCutoff(; λ, γ, Δs=2.0)\n\nConstruct a model spectral density with a Drude-Lorentz cutoff.\n\nJ(ω) = frac2λΔs^2 fracω γω^2 + γ^2\n\nwhere Δs is the distance between the two system states.\n\n\n\n\n\n","category":"type"},{"location":"tutorial/ExternalFieldDynamics/#Dynamics-in-presence-of-an-external-light","page":"Dynamics under External Fields","title":"Dynamics in presence of an external light","text":"","category":"section"},{"location":"tutorial/ExternalFieldDynamics/","page":"Dynamics under External Fields","title":"Dynamics under External Fields","text":"It has been shown that dissipative tunneling dynamics can be controlled by continuous wave light. We replicate some of the results here. ","category":"page"},{"location":"tutorial/ExternalFieldDynamics/","page":"Dynamics under External Fields","title":"Dynamics under External Fields","text":"As usual, first, we set up the system:","category":"page"},{"location":"tutorial/ExternalFieldDynamics/","page":"Dynamics under External Fields","title":"Dynamics under External Fields","text":"using QuantumDynamics\nusing Plots, LaTeXStrings\n\nH0 = [0.0+0.0im -1.0; -1.0 0.0]   # 1.1 Define the system Hamiltonian\nV(t) = 11.96575 * cos(10.0 * t)   # This is the monochromatic light\nEF = Utilities.ExternalField(V, [1.0+0.0im 0.0; 0.0 -1.0])\nJw = SpectralDensities.ExponentialCutoff(; ξ=0.16, ωc=7.5)    # 1.2 Define the spectral density\nβ = 0.5    # 1.3 Inverse temperature\nnothing","category":"page"},{"location":"tutorial/ExternalFieldDynamics/","page":"Dynamics under External Fields","title":"Dynamics under External Fields","text":"Calculate the forward-backward propagators. For the case with the external field, we use the Propagators.calculate_bare_propagators_external_field function.","category":"page"},{"location":"tutorial/ExternalFieldDynamics/","page":"Dynamics under External Fields","title":"Dynamics under External Fields","text":"dt = 0.125\nntimes = 100\nfbU = Propagators.calculate_bare_propagators(; Hamiltonian=H0, dt=dt, ntimes=ntimes, external_fields=[EF])\nnofield_fbU = Propagators.calculate_bare_propagators(; Hamiltonian=H0, dt=dt, ntimes=ntimes)\nnothing # suppress output","category":"page"},{"location":"tutorial/ExternalFieldDynamics/","page":"Dynamics under External Fields","title":"Dynamics under External Fields","text":"Simulate the system with the field. TTM does not yet work with time-dependent Hamiltonians. So, we resort to plain QuAPI.","category":"page"},{"location":"tutorial/ExternalFieldDynamics/","page":"Dynamics under External Fields","title":"Dynamics under External Fields","text":"ρ0 = [1.0+0.0im 0; 0 0]\nsigma_z = []\nkmax = 1:2:9\ntime = Vector{Float64}()\nfor k in kmax\n    @time t, ρs = QuAPI.propagate(; fbU=fbU, Jw=[Jw], β=β, ρ0=ρ0, dt=dt, ntimes=ntimes, kmax=k)\n    global time = t\n    push!(sigma_z, real.(ρs[:,1,1] .- ρs[:,2,2]))\nend","category":"page"},{"location":"tutorial/ExternalFieldDynamics/","page":"Dynamics under External Fields","title":"Dynamics under External Fields","text":"Use TTM to simulate the case without the external field.","category":"page"},{"location":"tutorial/ExternalFieldDynamics/","page":"Dynamics under External Fields","title":"Dynamics under External Fields","text":"sigma_z_nofield = []\nkmax = 1:2:9\ntime = Vector{Float64}()\nfor k in kmax\n    @time t, ρs = TTM.propagate(; fbU=nofield_fbU, Jw=[Jw], β=β, ρ0=ρ0, dt=dt, ntimes=ntimes, rmax=k, extraargs=QuAPI.QuAPIArgs(), path_integral_routine=QuAPI.build_augmented_propagator)\n    global time = t\n    push!(sigma_z_nofield, real.(ρs[:,1,1] .- ρs[:,2,2]))\nend","category":"page"},{"location":"tutorial/ExternalFieldDynamics/","page":"Dynamics under External Fields","title":"Dynamics under External Fields","text":"Obtain the Markovian dynamics in presence of light but in absence of the dissipative medium. ","category":"page"},{"location":"tutorial/ExternalFieldDynamics/","page":"Dynamics under External Fields","title":"Dynamics under External Fields","text":"time, ρs_nodissip = Utilities.apply_propagator(; propagators=fbU, ρ0=ρ0, ntimes=ntimes, dt=dt)\nnothing","category":"page"},{"location":"tutorial/ExternalFieldDynamics/","page":"Dynamics under External Fields","title":"Dynamics under External Fields","text":"Plot the results.","category":"page"},{"location":"tutorial/ExternalFieldDynamics/","page":"Dynamics under External Fields","title":"Dynamics under External Fields","text":"colors = [\"red\" \"green\" \"blue\" \"teal\" \"magenta\"]\nplot(time, sigma_z, lw=2, label=permutedims([\"Light k = $k\" for k in kmax]), seriescolor=colors)\nplot!(time, sigma_z_nofield, lw=2, ls=:dash, label=permutedims([\"No light r = $k\" for k in kmax]), seriescolor=colors)\nplot!(time, real.(ρs_nodissip[:,1,1] .- ρs_nodissip[:,2,2]), lw=2, label=\"No dissipation\")\nxlabel!(L\"t\")\nylabel!(L\"\\langle\\sigma_z(t)\\rangle\")","category":"page"},{"location":"tutorial/ExternalFieldDynamics/","page":"Dynamics under External Fields","title":"Dynamics under External Fields","text":"The localization phenomenon, though not as pronounced as in absence of dissipative media, is still clearly visible. As a comparison, we also simulate the dynamics in presence of a light pulse","category":"page"},{"location":"tutorial/ExternalFieldDynamics/","page":"Dynamics under External Fields","title":"Dynamics under External Fields","text":"V1(t) = 11.96575 * cos(10.0 * t) * exp(-t^2 / 8)   # This is the light pulse\nEF1 = Utilities.ExternalField(V1, [1.0+0.0im 0.0; 0.0 -1.0])\nfbU_pulse = Propagators.calculate_bare_propagators(; Hamiltonian=H0, dt=dt, ntimes=ntimes, external_fields=[EF1])\nkmax = 1:2:9\n@time time, ρs = QuAPI.propagate(; fbU=fbU_pulse, Jw=[Jw], β=β, ρ0=ρ0, dt=dt, ntimes=ntimes, kmax=9)\nsigma_z_pulse = real.(ρs[:,1,1] .- ρs[:,2,2])\nnothing","category":"page"},{"location":"tutorial/ExternalFieldDynamics/","page":"Dynamics under External Fields","title":"Dynamics under External Fields","text":"Plot the results.","category":"page"},{"location":"tutorial/ExternalFieldDynamics/","page":"Dynamics under External Fields","title":"Dynamics under External Fields","text":"colors = [\"black\"]\nplot(time, sigma_z_nofield[end], lw=2, ls=:dashdotdot, label=\"No light\", seriescolor=colors)\nplot!(time, sigma_z[end], lw=2, label=\"CW k = $(kmax[end])\", seriescolor=colors)\nplot!(time, sigma_z_pulse, lw=2, ls=:dash, label=\"Pulse k = 9\", seriescolor=colors)\nxlabel!(L\"t\")\nylabel!(L\"\\langle\\sigma_z(t)\\rangle\")","category":"page"},{"location":"tutorial/BasicPI/#Numerically-Exact-Path-Integral-Approaches","page":"Path Integrals","title":"Numerically Exact Path Integral Approaches","text":"","category":"section"},{"location":"tutorial/BasicPI/","page":"Path Integrals","title":"Path Integrals","text":"The family of methods based on Quasi-Adiabatic Propagator Path Integral (QuAPI) is a family of numerically exact non-perturbative techniques for simulating a quantum system interacting with a harmonic environment. It simulates the reduced density matrix of an n-level quantum system using path integrals and the harmonic bath is incorporated through the Feynman-Vernon influence functional. The tracing out of the harmonic bath leads to a non-Markovian memory, which is used as a convergence parameter.","category":"page"},{"location":"tutorial/BasicPI/","page":"Path Integrals","title":"Path Integrals","text":"While at a first glance, the restriction to harmonic environments may seem arbitrarily limiting, it is actually quite general. Under the Gaussian response theory, when the environment is large and has enough \"independent\" degrees of freedom, the impact of an atomistically-described environment can be mapped onto a bath of harmonic oscillators with given frequencies and coupling strengths. Together these frequencies and couplings are described through the spectral density of the solvent which is given by","category":"page"},{"location":"tutorial/BasicPI/","page":"Path Integrals","title":"Path Integrals","text":"J(omega) = fracpi2 sum_j fracc_j^2omega_jdeltaleft(omega-omega_jright)","category":"page"},{"location":"tutorial/BasicPI/","page":"Path Integrals","title":"Path Integrals","text":"The full system-harmonic environment Hamiltonian is then given by","category":"page"},{"location":"tutorial/BasicPI/","page":"Path Integrals","title":"Path Integrals","text":"hatH = hatH_0 + hatH_textenv\nhatH_textenv = sum_j fracp_j^22 + frac12omega_j^2left(x_j - fracc_jomega_j^2hatsright)^2","category":"page"},{"location":"tutorial/BasicPI/","page":"Path Integrals","title":"Path Integrals","text":"where hats is the system operator that interacts with the environment.","category":"page"},{"location":"tutorial/BasicPI/","page":"Path Integrals","title":"Path Integrals","text":"The most common prototypical model problem of open quantum systems is the spin-boson problem. We will illustrate the approach taken by QuantumDynamics to make the various methods compatible with each other by demonstrating how the same basic setup works for all the basic methods.","category":"page"},{"location":"tutorial/BasicPI/","page":"Path Integrals","title":"Path Integrals","text":"The basic steps involved for these simulations are","category":"page"},{"location":"tutorial/BasicPI/","page":"Path Integrals","title":"Path Integrals","text":"Define the system\nDefine the Hamiltonian\nDefine the spectral density corresponding to the solvent\nSpecify the temperature\nObtain the short-time propagators that are used to construct the path integral\nBuild on top of the short-time propagators using the Feynman-Vernon influence functional.","category":"page"},{"location":"tutorial/BasicPI/","page":"Path Integrals","title":"Path Integrals","text":"In this tutorial, we will show how to use the different methods of the QuAPI family to obtain results for a single parameter. This side-by-side use of all the algorithms serve to emphasize the similarity of the APIs involved.","category":"page"},{"location":"tutorial/BasicPI/","page":"Path Integrals","title":"Path Integrals","text":"using QuantumDynamics\nusing Plots, LaTeXStrings\n\nH0 = [0.0+0.0im -1.0; -1.0 0.0]   # 1.1 Define the system Hamiltonian\nJw = SpectralDensities.ExponentialCutoff(; ξ=0.1, ωc=7.5)    # 1.2 Define the spectral density\nβ = 5.0    # 1.3 Inverse temperature\nnothing","category":"page"},{"location":"tutorial/BasicPI/","page":"Path Integrals","title":"Path Integrals","text":"Let us plot the spectral density:","category":"page"},{"location":"tutorial/BasicPI/","page":"Path Integrals","title":"Path Integrals","text":"ω = 0:0.1:100\nplot(ω, Jw.(ω), lw=2, label=\"\")\nxlabel!(L\"\\omega\")\nylabel!(L\"J(\\omega)\")","category":"page"},{"location":"tutorial/BasicPI/","page":"Path Integrals","title":"Path Integrals","text":"Next, we calculate the short-time forward-backward propagators, which require us to define the time-step and number of steps of simulation.","category":"page"},{"location":"tutorial/BasicPI/","page":"Path Integrals","title":"Path Integrals","text":"dt = 0.25\nntimes = 100\nfbU = Propagators.calculate_bare_propagators(; Hamiltonian=H0, dt=dt, ntimes=ntimes)\nnothing # suppress output","category":"page"},{"location":"tutorial/BasicPI/#Iterative-Quasi-Adiabatic-propagator-Path-Integral-(QuAPI)","page":"Path Integrals","title":"Iterative Quasi-Adiabatic propagator Path Integral (QuAPI)","text":"","category":"section"},{"location":"tutorial/BasicPI/","page":"Path Integrals","title":"Path Integrals","text":"Finally, the methods incorporate the influence functional on top of the propagator. First, we demonstrate the basic QuAPI algorithm (QuAPI review) at different memory lengths, kmax. The exact method can also be used with filtering if the optional argument of extraargs of type QuAPI.QuAPIArgs is provided.","category":"page"},{"location":"tutorial/BasicPI/","page":"Path Integrals","title":"Path Integrals","text":"ρ0 = [1.0+0.0im 0; 0 0]\nsigma_z = []\nkmax = 1:2:9\ntime = Vector{Float64}()\nfor k in kmax\n    @time t, ρs = QuAPI.propagate(; fbU=fbU, Jw=[Jw], β=β, ρ0=ρ0, dt=dt, ntimes=ntimes, kmax=k)\n    global time = t\n    push!(sigma_z, real.(ρs[:,1,1] .- ρs[:,2,2]))\nend","category":"page"},{"location":"tutorial/BasicPI/","page":"Path Integrals","title":"Path Integrals","text":"colors = [\"red\" \"green\" \"blue\" \"teal\" \"magenta\"]\nplot(time, sigma_z, lw=2, label=permutedims([L\"k = %$k\" for k in kmax]), seriescolor=colors)\nxlabel!(L\"t\")\nylabel!(L\"\\langle\\sigma_z(t)\\rangle\")","category":"page"},{"location":"tutorial/BasicPI/#Tensor-Network-Path-Integral-(TNPI)","page":"Path Integrals","title":"Tensor Network Path Integral (TNPI)","text":"","category":"section"},{"location":"tutorial/BasicPI/","page":"Path Integrals","title":"Path Integrals","text":"Recently ideas of tensor network have been used to make path integral calculations more efficient. The correlation between the time-points decrease with the temporal separation between them. This allows for significantly compressed matrix product state (MPS) representation of the so-called path-amplitude tensor. The influence functional is represented as a matrix product operator and applied to this path-amplitude MPS to incorporate the effect of the baths. The interface is kept consistent with the other path integral methods like QuAPI. The MPO-MPS applications is controlled through a cutoff threshold and a maxdim threshold. The method used for applying an MPO to an MPS can be chosen to be one of naive and densitymatrix. These settings are passed as extraargs, which is an object of TNPI.TNPIArgs. By default, cutoff=1e-8, maxdim=50 and method=naive. These ideas have been outlined in TEMPO and TNPI.","category":"page"},{"location":"tutorial/BasicPI/","page":"Path Integrals","title":"Path Integrals","text":"ρ0 = [1.0+0.0im 0; 0 0]\nsigma_z_TNPI = []\nkmax = 2:2:9\ntime = Vector{Float64}()\nfor k in kmax\n    @time t, ρs = TNPI.propagate(; fbU=fbU, Jw=[Jw], β=β, ρ0=ρ0, dt=dt, ntimes=ntimes, kmax=k)\n    global time = t\n    push!(sigma_z_TNPI, real.(ρs[:,1,1] .- ρs[:,2,2]))\nend","category":"page"},{"location":"tutorial/BasicPI/","page":"Path Integrals","title":"Path Integrals","text":"colors = [\"red\" \"green\" \"blue\" \"teal\" \"magenta\"]\nplot(time, sigma_z_TNPI, lw=2, label=permutedims([L\"k = %$k\" for k in kmax]), seriescolor=colors[2:end])\nxlabel!(L\"t\")\nylabel!(L\"\\langle\\sigma_z(t)\\rangle\")","category":"page"},{"location":"tutorial/BasicPI/#Transfer-Tensor-Method-with-QuAPI-and-Blips","page":"Path Integrals","title":"Transfer Tensor Method with QuAPI and Blips","text":"","category":"section"},{"location":"tutorial/BasicPI/","page":"Path Integrals","title":"Path Integrals","text":"Since the iteration regime can be quite costly, we have implemented an extension to the non-Markovian transfer tensor method (TTM) (TTM) which is compatible with the QuAPI scheme. This is invoked in the following manner:","category":"page"},{"location":"tutorial/BasicPI/","page":"Path Integrals","title":"Path Integrals","text":"ρ0 = [1.0+0.0im 0; 0 0]\nsigma_z = []\nrmax = 1:2:9\ntime = Vector{Float64}()\nfor r in rmax\n    @time t, ρs = TTM.propagate(; fbU=fbU, Jw=[Jw], β=β, ρ0=ρ0, dt=dt, ntimes=ntimes, rmax=r, extraargs=QuAPI.QuAPIArgs(), path_integral_routine=QuAPI.build_augmented_propagator)\n    global time = t\n    push!(sigma_z, real.(ρs[:,1,1] .- ρs[:,2,2]))\nend","category":"page"},{"location":"tutorial/BasicPI/","page":"Path Integrals","title":"Path Integrals","text":"The TTM.propagate method, in addition to the usual arguments, takes a function to build the initial propagators for the full-path regime of the simulation. In this case, we are using QuAPI to build the propagators in the full-path segment, as indicated by path_integral_routine=QuAPI.build_augmented_propagator. Other possible choices are path_integral_routine=Blip.build_augmented_propagator and path_integral_routine=TNPI.build_augmented_propagator. Also notice that because each of these path_integral_routines take different extraargs, it is not possible to provide a default. Here, it is necessary for the extraargs to be provided and it needs to be consistent with the path_integral_routine.","category":"page"},{"location":"tutorial/BasicPI/","page":"Path Integrals","title":"Path Integrals","text":"colors = [\"red\" \"green\" \"blue\" \"teal\" \"magenta\"]\nplot(time, sigma_z, lw=2, label=permutedims([L\"k = %$r\" for r in rmax]), seriescolor=colors)\nxlabel!(L\"t\")\nylabel!(L\"\\langle\\sigma_z(t)\\rangle\")","category":"page"},{"location":"tutorial/BasicPI/","page":"Path Integrals","title":"Path Integrals","text":"TTM can also use the so-called blip-decomposed propagators where the augmented propagators are calculated using blip-decomposed path integrals. The code remains practically identical, except the path_integral_routine argument changes from QuAPI.build_augmented_propagator to Blip.build_augmented_propagator.","category":"page"},{"location":"tutorial/BasicPI/","page":"Path Integrals","title":"Path Integrals","text":"ρ0 = [1.0+0.0im 0; 0 0]\nsigma_z = []\nrmax = 1:2:9\ntime = Vector{Float64}()\nfor r in rmax\n    @time t, ρs = TTM.propagate(; fbU=fbU, Jw=[Jw], β=β, ρ0=ρ0, dt=dt, ntimes=ntimes, rmax=r, extraargs=Blip.BlipArgs(), path_integral_routine=Blip.build_augmented_propagator)\n    global time = t\n    push!(sigma_z, real.(ρs[:,1,1] .- ρs[:,2,2]))\nend","category":"page"},{"location":"tutorial/BasicPI/","page":"Path Integrals","title":"Path Integrals","text":"colors = [\"red\" \"green\" \"blue\" \"teal\" \"magenta\"]\nplot(time, sigma_z, lw=2, label=permutedims([L\"k = %$r\" for r in rmax]), seriescolor=colors)\nxlabel!(L\"t\")\nylabel!(L\"\\langle\\sigma_z(t)\\rangle\")","category":"page"},{"location":"documentation/QuAPI/#Quasi-Adiabatic-Propagator-Path-Integral-(QuAPI)","page":"Quasi-Adiabatic Propagator Path Integral","title":"Quasi-Adiabatic Propagator Path Integral (QuAPI)","text":"","category":"section"},{"location":"documentation/QuAPI/","page":"Quasi-Adiabatic Propagator Path Integral","title":"Quasi-Adiabatic Propagator Path Integral","text":"This module provides the basic interface for simulating a system using QuAPI. Though the implementation does not follow the algorithm in the original papers, the first papers to outline the method are QuAPI1 and QuAPI2. For an overall review of the ideas involved, consider reading QuAPI review. ","category":"page"},{"location":"documentation/QuAPI/#API","page":"Quasi-Adiabatic Propagator Path Integral","title":"API","text":"","category":"section"},{"location":"documentation/QuAPI/","page":"Quasi-Adiabatic Propagator Path Integral","title":"Quasi-Adiabatic Propagator Path Integral","text":"The API has three important end-points for user interface.","category":"page"},{"location":"documentation/QuAPI/","page":"Quasi-Adiabatic Propagator Path Integral","title":"Quasi-Adiabatic Propagator Path Integral","text":"First, there is the propagate function for propagating a given reduced density matrix.","category":"page"},{"location":"documentation/QuAPI/","page":"Quasi-Adiabatic Propagator Path Integral","title":"Quasi-Adiabatic Propagator Path Integral","text":"QuAPI.propagate","category":"page"},{"location":"documentation/QuAPI/#QuantumDynamics.QuAPI.propagate","page":"Quasi-Adiabatic Propagator Path Integral","title":"QuantumDynamics.QuAPI.propagate","text":"propagate(; fbU::Matrix{ComplexF64}, Jw::Vector{T}, β::Real, ρ0, dt::Real, ntimes::Int, kmax::Int, extraargs::QuAPIArgs=QuAPIArgs(), svec=[1.0 -1.0], reference_prop=false, verbose::Bool=false) where {T<:SpectralDensities.SpectralDensity}\n\nGiven a time-series of system forward-backward propagators, fbU, the spectral densities describing the solvent, Jw, and an inverse temperature, this uses QuAPI to propagate the input initial reduced density matrix, ρ0, with a time-step of dt for ntimes time steps. A non-Markovian memory of kmax steps is used in this simulation. The i^th bath, described by Jw[i], interacts with the system through the diagonal operator with the values of svec[j,:].\n\n`ρ0`: initial reduced density matrix\n`fbU`: time-series of forward-backward propagators\n`Jw`: array of spectral densities\n`svec`: diagonal elements of system operators through which the corresponding baths interact. QuAPI currently only works for baths with diagonal coupling to the system\n\n`dt`: time-step for recording the density matrices\n`ntimes`: number of time steps of simulation\n`kmax`: number of steps within memory\n`extraargs`: extra arguments for the QuAPI algorithm. Contains the filtration cutoff threshold\n\n\n\n\n\n","category":"function"},{"location":"documentation/QuAPI/","page":"Quasi-Adiabatic Propagator Path Integral","title":"Quasi-Adiabatic Propagator Path Integral","text":"Then, there is the build_augmented_propagator function for computing the augmented propagator incorporating the solvent effects through the Feynman-Vernon influence functional. This currently only does a full path calculation and does not iterate.","category":"page"},{"location":"documentation/QuAPI/","page":"Quasi-Adiabatic Propagator Path Integral","title":"Quasi-Adiabatic Propagator Path Integral","text":"QuAPI.build_augmented_propagator","category":"page"},{"location":"documentation/QuAPI/#QuantumDynamics.QuAPI.build_augmented_propagator","page":"Quasi-Adiabatic Propagator Path Integral","title":"QuantumDynamics.QuAPI.build_augmented_propagator","text":"build_augmented_propagator(; fbU::Matrix{ComplexF64}, Jw::Vector{T}, β::Real, dt::Real, ntimes::Int, extraargs=QuAPIArgs(), svec=[1.0 -1.0], reference_prop=false, verbose::Bool=false) where {T<:SpectralDensities.SpectralDensity}\n\nBuilds the propagators, augmented with the influence of the harmonic baths defined by the spectral densities Jw,  upto ntimes time-steps without iteration. The paths are generated in full forward-backward space but not stored. So, while the space requirement is minimal and constant, the time complexity for each time-step grows by an additional factor of d^2, where d is the dimensionality of the system. This i^th bath, described by Jw[i], interacts with the system through the diagonal operator with the values of svec[j,:].\n\n\n\n\n\n","category":"function"},{"location":"documentation/QuAPI/","page":"Quasi-Adiabatic Propagator Path Integral","title":"Quasi-Adiabatic Propagator Path Integral","text":"QuAPI allows for path filtering based on the absolute value of the amplitude of a path. This cutoff threshold is specified using the QuAPIArgs structure. QuAPI.propagate and QuAPI.build_augmented_propagator use objects of this structure, with a default value being the default constructed objected.","category":"page"},{"location":"documentation/QuAPI/","page":"Quasi-Adiabatic Propagator Path Integral","title":"Quasi-Adiabatic Propagator Path Integral","text":"QuAPI.QuAPIArgs","category":"page"},{"location":"documentation/QuAPI/#QuantumDynamics.QuAPI.QuAPIArgs","page":"Quasi-Adiabatic Propagator Path Integral","title":"QuantumDynamics.QuAPI.QuAPIArgs","text":"Filtration parameters for QuAPI. Currently has a threshold for magnitude-based filtering, with a default value of cutoff=0 (no filtering).\n\n\n\n\n\n","category":"type"},{"location":"documentation/Blip/#Blip-decomposition-of-the-path-integral","page":"Blip Decomposition","title":"Blip decomposition of the path integral","text":"","category":"section"},{"location":"documentation/Blip/","page":"Blip Decomposition","title":"Blip Decomposition","text":"The blip decomposition of the path integral, Blip1 and Blip2, is a different representation of the path integral that significantly reduces the number of \"paths\" that need to be considered.","category":"page"},{"location":"documentation/Blip/#API","page":"Blip Decomposition","title":"API","text":"","category":"section"},{"location":"documentation/Blip/","page":"Blip Decomposition","title":"Blip Decomposition","text":"Blip.build_augmented_propagator","category":"page"},{"location":"documentation/Blip/#QuantumDynamics.Blip.build_augmented_propagator","page":"Blip Decomposition","title":"QuantumDynamics.Blip.build_augmented_propagator","text":"build_augmented_propagator(; fbU::Matrix{ComplexF64}, Jw::Vector{T}, β::Real, dt::Real, ntimes::Int, extraargs::BlipArgs=BlipArgs(), svec=[1.0 -1.0], reference_prop=false, verbose::Bool=false) where {T<:SpectralDensities.SpectralDensity}\n\nBuilds the propagators, augmented with the influence of the harmonic baths defined by the spectral densities Jw,  upto ntimes time-steps without iteration using the blip decomposition. The paths are, consequently, generated in the space of unique blips and not stored. So, while the space requirement is minimal and constant, the time complexity for each time-step grows by an additional factor of b, where b is the number of unique blip-values. The i^th bath, described by Jw[i], interacts with the system through the diagonal operator with the values of svec[j,:].\n\n\n\n\n\n","category":"function"},{"location":"documentation/Blip/","page":"Blip Decomposition","title":"Blip Decomposition","text":"Blip.BlipArgs","category":"page"},{"location":"documentation/Blip/#QuantumDynamics.Blip.BlipArgs","page":"Blip Decomposition","title":"QuantumDynamics.Blip.BlipArgs","text":"Filtration parameters for blips. Currently has the maximum number of blips allowed which by default is nothing (implying all blips are allowed).\n\n\n\n\n\n","category":"type"},{"location":"tutorial/HEOM/#Hierarchy-Equation-of-Motion","page":"Hierarchy Equation of Motion","title":"Hierarchy Equation of Motion","text":"","category":"section"},{"location":"tutorial/HEOM/","page":"Hierarchy Equation of Motion","title":"Hierarchy Equation of Motion","text":"The HEOM family of methods is an extremely popular set of methods for solving the system-harmonic bath problem. While exact like QuAPI, its initial formulation was efficient for the Ohmic spectral density with a Drude-Lorentz cutoff. While a lot of significant work has gone into improving the performance of the method, and increasing the generality, the implementation in QuAPI is currently quite basic and can only handle Drude spectral densities.","category":"page"},{"location":"tutorial/HEOM/","page":"Hierarchy Equation of Motion","title":"Hierarchy Equation of Motion","text":"TO propagate an initial reduced density matrix using HEOM, we define a Hamiltonian and specify the spectral density and the temperature. Unlike QuAPI, HEOM can incorporate baths interacting with the system through non-diagonal operators without any increase in the complexity of the algorithm. However, for comparison purposes, in this tutorial, we restrict our attention to diagonal system-bath couplings.","category":"page"},{"location":"tutorial/HEOM/","page":"Hierarchy Equation of Motion","title":"Hierarchy Equation of Motion","text":"H = [1.0+0.0im -1.0; -1.0 -1.0]\nρ0 = [1.0+0.0im 0; 0 0]\nβ = 0.5\nJw = SpectralDensities.DrudeLorentzCutoff(; λ=1.5, γ=7.5)\ndt = 0.125\nntimes = 200","category":"page"},{"location":"tutorial/HEOM/","page":"Hierarchy Equation of Motion","title":"Hierarchy Equation of Motion","text":"We call the propagate function","category":"page"},{"location":"tutorial/HEOM/","page":"Hierarchy Equation of Motion","title":"Hierarchy Equation of Motion","text":"times_HEOM, ρs_HEOM = HEOM.propagate(; Hamiltonian=H, ρ0, β, dt, ntimes, Jw=[Jw], sys_ops=[[1.0+0.0im 0.0; 0.0 -1.0]], num_modes=1, Lmax=2)","category":"page"},{"location":"tutorial/HEOM/","page":"Hierarchy Equation of Motion","title":"Hierarchy Equation of Motion","text":"For comparison, we also simulate the system using QuAPI and plot the results.","category":"page"},{"location":"tutorial/HEOM/","page":"Hierarchy Equation of Motion","title":"Hierarchy Equation of Motion","text":"barefbU = Propagators.calculate_bare_propagators(; Hamiltonian=H, dt, ntimes);\ntimes, ρs = TNPI.propagate(; fbU=barefbU, Jw=[Jw], β, ρ0, dt, ntimes, kmax=100)\nplot(times, real.(ρs[:,1,1].-ρs[:,2,2]), label=\"QuAPI\", lw=2)\nplot!(times_HEOM, real.(ρs_HEOM[:,1,1].-ρs_HEOM[:,2,2]), label=\"HEOM\", lw=2, ls=:dash)","category":"page"},{"location":"documentation/Bare/#Bare-System-Propagation","page":"Bare System Propagation","title":"Bare System Propagation","text":"","category":"section"},{"location":"documentation/Bare/#API","page":"Bare System Propagation","title":"API","text":"","category":"section"},{"location":"documentation/Bare/","page":"Bare System Propagation","title":"Bare System Propagation","text":"Bare.propagate","category":"page"},{"location":"documentation/Bare/#QuantumDynamics.Bare.propagate","page":"Bare System Propagation","title":"QuantumDynamics.Bare.propagate","text":"propagate(; Hamiltonian::Matrix{ComplexF64}, ρ0::Matrix{ComplexF64}, dt::Real, ntimes::Int, L::Union{Nothing, Vector{Matrix{ComplexF64}}}=nothing, extraargs::Utilities.DiffEqArgs=Utilities.DiffEqArgs())\n\nGiven a potentially non-Hermitian Hamiltonian, this solves the equation of motion to propagate the input initial reduced density matrix, ρ0, with a time-step of dt for ntimes time steps. If a solution to the Linblad Master Equation is desired, make the Hamiltonian Hermitian, and keep all the non-Hermitian dissipative operators in L.\n\n\n\n\n\n","category":"function"},{"location":"documentation/TNPI/#Tensor-Network-Path-Integral","page":"Tensor Network Path Integral","title":"Tensor Network Path Integral","text":"","category":"section"},{"location":"documentation/TNPI/","page":"Tensor Network Path Integral","title":"Tensor Network Path Integral","text":"Tensor Network Path Integral (TNPI) uses matrix product states and operators to reduces the computational complexity and storage requirement for doing a path integral simulation. This allows for simulation of significantly larger systems with longer lengths of non-Markovian memory. The fundamental ideas are outlined in TEMPO and TNPI.","category":"page"},{"location":"documentation/TNPI/#API","page":"Tensor Network Path Integral","title":"API","text":"","category":"section"},{"location":"documentation/TNPI/","page":"Tensor Network Path Integral","title":"Tensor Network Path Integral","text":"TNPI.propagate","category":"page"},{"location":"documentation/TNPI/#QuantumDynamics.TNPI.propagate","page":"Tensor Network Path Integral","title":"QuantumDynamics.TNPI.propagate","text":"propagate(; fbU::Matrix{ComplexF64}, Jw::Vector{T}, β::Real, ρ0, dt::Real, ntimes::Int, kmax::Int, extraargs::QuAPIArgs=QuAPIArgs(), svec=[1.0 -1.0], reference_prop=false, verbose::Bool=false) where {T<:SpectralDensities.SpectralDensity}\n\nGiven a time-series of system forward-backward propagators, fbU, the spectral densities describing the solvent, Jw, and an inverse temperature, this uses TNPI to propagate the input initial reduced density matrix, ρ0, with a time-step of dt for ntimes time steps. A non-Markovian memory of kmax steps is used in this simulation. The i^th bath, described by Jw[i], interacts with the system through the diagonal operator with the values of svec[j,:].\n\n`ρ0`: initial reduced density matrix\n`fbU`: time-series of forward-backward propagators\n`Jw`: array of spectral densities\n`svec`: diagonal elements of system operators through which the corresponding baths interact. QuAPI currently only works for baths with diagonal coupling to the system.\n\n`dt`: time-step for recording the density matrices\n`ntimes`: number of time steps of simulation\n`kmax`: number of steps within memory\n`extraargs`: extra arguments for the TNPI algorithm. Contains the `cutoff` threshold for SVD filtration, the maximum bond dimension, `maxdim`, and the `method` of applying an MPO to an MPS.\n\n\n\n\n\n","category":"function"},{"location":"documentation/QCPI/#Quantum-Classical-Path-Integral","page":"Quantum-Classical Path Integral","title":"Quantum-Classical Path Integral","text":"","category":"section"},{"location":"documentation/QCPI/","page":"Quantum-Classical Path Integral","title":"Quantum-Classical Path Integral","text":"QCPI provides a rigorous way of coupling a classical-like solvent to a quantum system. The method has been outlined in QCPI1, QCPI2, reference propagators.","category":"page"},{"location":"documentation/QCPI/#API","page":"Quantum-Classical Path Integral","title":"API","text":"","category":"section"},{"location":"documentation/QCPI/","page":"Quantum-Classical Path Integral","title":"Quantum-Classical Path Integral","text":"QCPI.propagate","category":"page"},{"location":"documentation/QCPI/#QuantumDynamics.QCPI.propagate","page":"Quantum-Classical Path Integral","title":"QuantumDynamics.QCPI.propagate","text":"propagate(; Hamiltonian::Matrix{ComplexF64}, Jw::SpectralDensities.SpectralDensity, solvent::Solvents.Solvent, ρ0::Matrix{ComplexF64}, classical_dt::Real, dt::Real, ntimes::Int, kmax::Int, path_integral_routine, extraargs::Utilities.ExtraArgs, svec=[1.0 -1.0], verbose::Bool=false)\n\nUse QCPI to propagate an initial density matrix, ρ0, under a given Hamiltonian with a solvent that is described by solvent and a corresponding spectral density Jw.\n\n\n\n\n\n","category":"function"},{"location":"documentation/QCPI/","page":"Quantum-Classical Path Integral","title":"Quantum-Classical Path Integral","text":"The solvent shown here is encoded in the Solvents submodule:","category":"page"},{"location":"documentation/QCPI/","page":"Quantum-Classical Path Integral","title":"Quantum-Classical Path Integral","text":"Solvents","category":"page"},{"location":"documentation/QCPI/#QuantumDynamics.Solvents","page":"Quantum-Classical Path Integral","title":"QuantumDynamics.Solvents","text":"General description of different types of solvents.\n\n\n\n\n\n","category":"module"},{"location":"documentation/QCPI/","page":"Quantum-Classical Path Integral","title":"Quantum-Classical Path Integral","text":"The Solvents submodule defines a general Solvent type and an associated PhaseSpace type.","category":"page"},{"location":"documentation/QCPI/","page":"Quantum-Classical Path Integral","title":"Quantum-Classical Path Integral","text":"Solvents.Solvent","category":"page"},{"location":"documentation/QCPI/#QuantumDynamics.Solvents.Solvent","page":"Quantum-Classical Path Integral","title":"QuantumDynamics.Solvents.Solvent","text":"Abstract type for every solvent. Every solvent needs to implement Base.iterate, which returns the next sample of the phase-space, and a propagate_trajectory method which propagates a given phasespace point using classical mechanics.\n\n\n\n\n\n","category":"type"},{"location":"documentation/QCPI/","page":"Quantum-Classical Path Integral","title":"Quantum-Classical Path Integral","text":"Solvents.PhaseSpace","category":"page"},{"location":"documentation/QCPI/#QuantumDynamics.Solvents.PhaseSpace","page":"Quantum-Classical Path Integral","title":"QuantumDynamics.Solvents.PhaseSpace","text":"Abstract type for all phase spaces. Each Solvent has an associated phase-space.\n\n\n\n\n\n","category":"type"},{"location":"documentation/EtaCoefficients/#η-Coefficients","page":"Eta Coefficients","title":"η-Coefficients","text":"","category":"section"},{"location":"documentation/EtaCoefficients/","page":"Eta Coefficients","title":"Eta Coefficients","text":"The η-coefficients are discretizations of the bath correlation function required for simulations using the QuAPI influence functionals. QuantumDynamics provides facilities for generating these coefficients and storing them in a way that utilizes the limited time-translational symmetry that they demonstrate. These coefficients have been listed in many papers, the first being QuAPI1.","category":"page"},{"location":"documentation/EtaCoefficients/#API","page":"Eta Coefficients","title":"API","text":"","category":"section"},{"location":"documentation/EtaCoefficients/","page":"Eta Coefficients","title":"Eta Coefficients","text":"EtaCoefficients.EtaCoeffs","category":"page"},{"location":"documentation/EtaCoefficients/#QuantumDynamics.EtaCoefficients.EtaCoeffs","page":"Eta Coefficients","title":"QuantumDynamics.EtaCoefficients.EtaCoeffs","text":"EtaCoefficients holds the various discretized η-coefficients required for a QuAPI-based simulation. These are the minimum number of coefficients required, stored using time-translational symmetry wherever possible.\n\nThe values are stored as follows:\n    η00: The self-interaction of the two terminal time points.\n    ηmm: The self-interaction of all intermediate points.\n    η0m: The interaction between a terminal and an intermediate point at different time separations.\n    ηmn: The interaction between two intermediate points at different time separations.\n    η0e: The interaction between the two terminal points at different time separations.\n\n\n\n\n\n","category":"type"},{"location":"documentation/EtaCoefficients/","page":"Eta Coefficients","title":"Eta Coefficients","text":"EtaCoefficients.calculate_η","category":"page"},{"location":"documentation/EtaCoefficients/#QuantumDynamics.EtaCoefficients.calculate_η","page":"Eta Coefficients","title":"QuantumDynamics.EtaCoefficients.calculate_η","text":"calculate_η(specdens<:SpectralDensities.AnalyticalSpectralDensity; β::Real, dt::Real, kmax::Int, classical::Bool=false, discrete::Bool=false)\n\nCalculates the η-coefficients from an analytic spectral density and returns them as an object of the structure EtaCoeffs. The integrations involved are done using trapezoidal integration\n\n\n\n\n\ncalculate_η(specdens::T; β::Real, dt::Real, kmax::Int, classical::Bool=false, imaginary_only=false) where {T<:SpectralDensities.ContinuousSpectralDensity}\n\nCalculates the η-coefficients from a a tabulated spectral density and returns them as an object of the structure EtaCoeffs.\n\n\n\n\n\ncalculate_η(specdens::T; β::Real, dt::Real, kmax::Int, classical::Bool=false, imaginary_only=false) where {T<:SpectralDensities.DiscreteOscillators}\n\nCalculates the η-coefficients from a discretized set of harmonic modes and returns them as an object of the structure EtaCoeffs. The integrations involved are converted to sums over frequency modes.\n\n\n\n\n\n","category":"function"},{"location":"#Quantum-Dynamics","page":"Introduction","title":"Quantum Dynamics","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Documentation\n[![docs-dev][docsdev-img]][docsdev-url]","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"[docsdev-img]: https://img.shields.io/badge/docs-dev-blue.svg [docsdev-url]: https://amartyabose.github.io/QuantumDynamics/dev/","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"QuantumDynamics is an open-source software for the simulation of open quantum systems. Though written with performance in mind, QuantumDynamics provides a high throughput platform for experimentation with state-of-the-art approaches to method development.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The primary problem that QuantumDynamics is aimed at solving is simulation of the dynamics of a relatively small quantum system coupled to a dissipative environment. Such a system-solvent decomposed problem can typically be represented by the Hamiltonian:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"hatH = hatH_0 + hatH_textenv","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"where hatH_0 is the Hamiltonian of the isolated system and hatH_textenv is the Hamiltonian corresponding to the environment and the interaction between the system and the environment.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"As demonstrated in the tutorials and the example codes, QuantumDynamics provides some approximate methods for simulating the dynamics of the system. However, the goal of this package is to provide access to more state-of-the-art techniques based on path integrals, tensor networks and other ideas in such a manner that all of these methods can be used as far as possible in a composable manner.","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The QuantumDynamics package has not yet been registered. For the time being, the installation procedure directly uses the github repository. This can either be done by going into the Pkg REPL mode for Julia","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"~ julia","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> ]\npkg> add https://github.com/amartyabose/QuantumDynamics","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"or by using the Pkg package manager in a script:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> using Pkg\njulia> Pkg.add(\"https://github.com/amartyabose/QuantumDynamics\")","category":"page"},{"location":"documentation/Utilities/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"documentation/Utilities/","page":"Utilities","title":"Utilities","text":"Collection of some utilities for simulations.","category":"page"},{"location":"documentation/Utilities/#API","page":"Utilities","title":"API","text":"","category":"section"},{"location":"documentation/Utilities/","page":"Utilities","title":"Utilities","text":"Utilities.ExternalField","category":"page"},{"location":"documentation/Utilities/#QuantumDynamics.Utilities.ExternalField","page":"Utilities","title":"QuantumDynamics.Utilities.ExternalField","text":"ExternalField provides an abstract interface for encoding an external field, V(t), interacting with the system through the operator, coupling_op.\n\n\n\n\n\n","category":"type"},{"location":"documentation/Utilities/","page":"Utilities","title":"Utilities","text":"Utilities.unhash_path","category":"page"},{"location":"documentation/Utilities/#QuantumDynamics.Utilities.unhash_path","page":"Utilities","title":"QuantumDynamics.Utilities.unhash_path","text":"unhash_path(path_num::Int, ntimes::Int, sdim::Int)\n\nConstruct a path for a system with sdim dimensions, corresponding to the number path_num, with ntimes time steps.\n\n\n\n\n\n","category":"function"},{"location":"documentation/Utilities/","page":"Utilities","title":"Utilities","text":"Utilities.apply_propagator","category":"page"},{"location":"documentation/Utilities/#QuantumDynamics.Utilities.apply_propagator","page":"Utilities","title":"QuantumDynamics.Utilities.apply_propagator","text":"apply_propagator(; propagators, ρ0, ntimes, dt)\n\nApply a series of ntimes propagators to an initial reduced density matrix ρ0 and return the result as a tuple of (time, ρs).\n\n\n\n\n\n","category":"function"},{"location":"documentation/Utilities/","page":"Utilities","title":"Utilities","text":"Many of the algorithms require extra, method-specific arguments. These are implemented as subtypes of Utilities.ExtraArgs.","category":"page"},{"location":"documentation/Utilities/","page":"Utilities","title":"Utilities","text":"Utilities.ExtraArgs","category":"page"},{"location":"documentation/Utilities/#QuantumDynamics.Utilities.ExtraArgs","page":"Utilities","title":"QuantumDynamics.Utilities.ExtraArgs","text":"Abstract type for encoding all the method specific numerical parameters.\n\n\n\n\n\n","category":"type"},{"location":"documentation/Utilities/","page":"Utilities","title":"Utilities","text":"Utilities.DiffEqArgs","category":"page"},{"location":"documentation/Utilities/#QuantumDynamics.Utilities.DiffEqArgs","page":"Utilities","title":"QuantumDynamics.Utilities.DiffEqArgs","text":"Extra parameters for solving differential equations. Currently has a threshold for magnitude-based filtering. The default values are:     reltol = 1e-10     abstol = 1e-10     solver = Tsit5()\n\n\n\n\n\n","category":"type"},{"location":"tutorial/Bloch-Redfield/#Bloch-Redfield-Master-Equation","page":"Bloch-Redfield Master Equation","title":"Bloch-Redfield Master Equation","text":"","category":"section"},{"location":"tutorial/Bloch-Redfield/","page":"Bloch-Redfield Master Equation","title":"Bloch-Redfield Master Equation","text":"QuantumDynamics also offers the option of simulating the dynamics of an open quantum system using the Bloch-Redfield equations. The main interface is similar to that of the path integral-based methods except for the crucial difference that instead of building on the forward-backward propagator, the Bloch-Redfield Master Equations (BRME) uses the Hamiltonian.","category":"page"},{"location":"tutorial/Bloch-Redfield/","page":"Bloch-Redfield Master Equation","title":"Bloch-Redfield Master Equation","text":"First, we define the system and the spectral density describing the solvent","category":"page"},{"location":"tutorial/Bloch-Redfield/","page":"Bloch-Redfield Master Equation","title":"Bloch-Redfield Master Equation","text":"using QuantumDynamics\nusing Plots, LaTeXStrings\n\nH0 = [0.0+0.0im -1.0; -1.0 0.0]   # 1.1 Define the system Hamiltonian\nJw = SpectralDensities.ExponentialCutoff(; ξ=0.1, ωc=7.5)    # 1.2 Define the spectral density\nβ = 5.0    # 1.3 Inverse temperature\ndt = 0.25\nntimes = 100\nρ0 = [1.0+0.0im 0; 0 0]\nnothing","category":"page"},{"location":"tutorial/Bloch-Redfield/","page":"Bloch-Redfield Master Equation","title":"Bloch-Redfield Master Equation","text":"The interface to BRME is provided in the Bloch-Redfield module as the propagate function.","category":"page"},{"location":"tutorial/Bloch-Redfield/","page":"Bloch-Redfield Master Equation","title":"Bloch-Redfield Master Equation","text":"time, ρs = BlochRedfield.propagate(; Hamiltonian=H0, Jw=[Jw], β, ρ0, dt, ntimes, svec=[[1.0 0.0; 0.0 -1.0]])\nnothing","category":"page"},{"location":"tutorial/Bloch-Redfield/","page":"Bloch-Redfield Master Equation","title":"Bloch-Redfield Master Equation","text":"Let's also do a QuAPI calculation for comparison:","category":"page"},{"location":"tutorial/Bloch-Redfield/","page":"Bloch-Redfield Master Equation","title":"Bloch-Redfield Master Equation","text":"fbU = Propagators.calculate_bare_propagators(; Hamiltonian=H0, dt=dt, ntimes=ntimes)\nt, ρs_quapi = QuAPI.propagate(; fbU=fbU, Jw=[Jw], β=β, ρ0=ρ0, dt=dt, ntimes=ntimes, kmax=7)\nnothing","category":"page"},{"location":"tutorial/Bloch-Redfield/","page":"Bloch-Redfield Master Equation","title":"Bloch-Redfield Master Equation","text":"plot(t, real.(ρs_quapi[:,1,1] .- ρs_quapi[:,2,2]), lw=2, label=\"QuAPI\")\nplot!(time, real.(ρs[:,1,1] .- ρs[:,2,2]), lw=2, label=\"BRME\")\nxlabel!(L\"t\")\nylabel!(L\"\\langle\\sigma_z(t)\\rangle\")","category":"page"}]
}
